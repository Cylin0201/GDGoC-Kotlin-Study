# 11장. 제네릭스
## 제네릭 타입과 함께 동작하는 함수와 프로퍼티
리스트를 다루는 함수를 작성한다면 어떤 특정 타입을 저장하는 리스트만이 아닌 모든 리스트를 다룰 수 있는 함수를 원할 것이다.
이럴 때 제네릭 함수를 작성해야 한다. 아래의 코드를 참고하자.

```kotlin
fun <T> List<T>.slice(indices: IntRange): List<T> // 타입 파라미터가 수신 객체와 반환 타입에 쓰인다.
```
함수의 파라미터 T가 수신 객체와 반환 타입에 쓰인다. 이런 함수를 구체적인 리스트에 대해 호출할 때에는 타입 인자를 명시적으로 지정할 수 있다.

## 제네릭을 사용하는 클래스
제네릭 클래스를 확장하는 클래스나, 구현하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다. 
이때 아래와 같은 방식으로 타입을 넘길 수 있다.

```kotlin
class StringList : List<String> {
    override fun get(index: Int): String = TODO()
}

class ArrayList<T> : List<T> {
    override fun get(index: Int): T = TODO()
}
```

ArrayList 클래스는 자신만의 타입 파라미터 T를 정의하면서 그 T를 기반 클래스의 타입 인자로 사용한다. 

## 타입 파라미터 제약
타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다. 
어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상계로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시
그 상계 타입이거나 그 상계 타입의 하위 타입이어야 한다.

제약을 가하려면 타입 파라미터 이름 뒤에 콜론을 표시하고 그 뒤에 상계 타입을 적으면 된다. 자바에서는 <T extends Number > T sum(List<T> list)처럼
extends를 써서 같은 개념을 표현한다.

```kotlin
fun <T : Number> List<T>.sum() : T
```

## 널이될 수 있는 타입 인자 제외시키기
아래와 같은 아무런 상계 타입을 정하지 않은 타입 파라미터는 Any?를 상계로 정한 파라미터와 같다.

```kotlin
class Processor<T>{
    fun process(value: T){
        value?.hashCode()   //value는 널이 될 수 있다. 따라서 안전한 호출을 사용해야 함.
    }
}
--------------------------------
class Processor<T : Any>{ //널이 될 수 없는 타입 상계를 지정한다.
    fun process(value: T){
        value?.hashCode()   
    }
}
```

## 실행 시점 제네릭스 동작
자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다. 이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.

```kotlin
val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)
```
컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만 실행 시점에 그 둘은 완전히 같다. 그럼에도 컴파일러가 타입 인자를 알고 올바른 탕비의 값만 각 리스트에 넣도록 보장한다.

실행 시점에 인라인 함수의 실제 타입인자를 알 수 있음을 이용하자. 어떤 함수에 inline 키워드를 붙이면 컴파일러는 그 함수를 호출한 식을 모두 함수로 현하는 코드로 바꾼다.

```kotlin
//11.7 실체화된 타입 파라미터를 사용하는 함수 정의하기
inline fun <reified T> isA(value: Any) = value is T

fun main(){
    println(isA<String>("abc")) //true
    println(isA<String>(123)) //false
    
}
```

## 변성
변성 개념은 List<String>과 List<Any> 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.
변성을 잘 활용하면 사용에 불편하지 않으면서 타입 안정성을 보장하는 API를 만들 수 있다.

List<Any> 타입의 파라미터를 받는 함수에 List<String>을 넘기면 안전한가? 어떤 함수가 리스트에 원소를 추가하거나 변경한다면
타입 불일치가 생길 수 있어 List<String>을 넘길 수 없다. 하지만 원소 추가나 변경이 없는 경우에는 안전하다.

### 하위 타입
어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 타입 B는 타입 A의 하위 타입이다. 
간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다. 

널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다. 하지만 두 타입 모두 같은 클래스에 해당한다. 
항상 널이 될 수 없는 타입의 값을 널이 될 수 있는 타입의 변수에 저장할 수 있지만 반대는 불가능하다.

어떤 제네릭 타입이 있는데 서로 다른 두 타입 A와 B에 대해 MutableList\<A>가 항상 MutableList\<B>의 하위타입도 아니고 상위 타입도 아닌 경우
이 제네릭 타입이 타입 파라미터에 대해 무공변이라고 말한다. 자바에서는 모든 클래스가 무공변이다.

### 공변성
공변적인 클래스는 제네릭 클래스에 대해 A가 B의 하위 타입일 때 Producer\<A>가 Producer\<B>의 하위 타입인 경우를 말한다. 
예를 들어 Cat이 Animal의 하위 타입이기 때문에 Producer\<Cat>은 Producer\<Animal>의 하위 타입이다. 

코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 한다.

```kotlin
interface Producer<out T>{
    fun produce() : T
}
```
클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도
그 클래스의 인스턴스를 함수 인자나 반환값으로 사용할 수 있다.

타입 파라미터 T에 붙은 out 키워드는 다음 2가지를 함께 의미한다.
- 하위 타입 관계가 유지된다
- T를 아웃 위치에서만 사용할 수 있다.

제네릭 클래스의 타입 인자가 어떤 타입인지 모르거나 타입 인자가 어떤 타입인지가 중요하지 않을 때 스타 프로젝션 그문을 사용할 수 있다.

타입 별명을 사용하면 타입에 대해 더 짧은 이름이나 다른 이름을 부여할 수 있다.